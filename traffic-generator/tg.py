#!/usr/bin/python

import iperf3


from argparse import ArgumentParser
from subprocess import Popen, PIPE
import sys
import re


def parse_data_server(data, verbose=False):
    if verbose:
        print('Parsing line:  %s' % data)
    # Search pattern
    m = re.search('\\s+(\\S+)\\s+sec\\s+(\\S+) MBytes\\s+(\\S+) Mbits/sec',
                  data)
    # Match
    if (m):
        # Extract interval
        interval = m.group(1)
        # Extract transfer (in MBytes)
        transfer = m.group(2)
        # Extract bandwidth (in Mbits/sec)
        bandwidth = m.group(3)
        # Build results dict
        res = {
            'interval': interval,
            'transfer': transfer,
            'bandwidth': bandwidth
        }
        if verbose:
            print('Got %s\n' % res)
        # Return results
        return res


def parse_data_client(data, verbose=False):
    if verbose:
        print('Parsing line:  %s' % data)
    # Search pattern
    m = re.search('\\s+(\\S+)\\s+sec\\s+(\\S+) MBytes\\s+(\\S+) Mbits/sec\\s+\\S+\\s+\\S+',
                  data)
    # Match
    if (m):
        # Extract interval
        interval = m.group(1)
        # Extract transfer (in MBytes)
        transfer = m.group(2)
        # Extract bandwidth (in Mbits/sec)
        bandwidth = m.group(3)
        # Build results dict
        res = {
            'interval': interval,
            'transfer': transfer,
            'bandwidth': bandwidth
        }
        if verbose:
            print('Got %s\n' % res)
        # Return results
        return res


def start_server(address, port=None, verbose=False):
    # Build the command to start the server
    cmd = 'iperf3 --forceflush --server --bind %s' % address
    if port is not None:
        cmd += ' --port %s' % port
    # Print command
    if verbose:
        print(cmd)
    # Execute the command in a new process and redirect output to PIPE
    p = Popen(cmd, shell=True, stdout=PIPE)
    # Iterate on the output generated by iperf3
    while True:
        # Read a line
        out = p.stdout.readline()
        # Check if the process has terminated
        if out == '' and p.poll() is not None:
            break
        # Parse the output generated by iperf3
        if out != '':
            # Parse data
            res = parse_data_server(out, verbose)
            if res is not None:
                pass  # TODO send data


def start_client(client_address, server_address, server_port=None,
                 duration=None, bandwidth=None, num_streams=None, mss=None,
                 bidir=False, reverse=False, zerocopy=False, version6=False,
                 verbose=False):
    # Build the command to start the server
    cmd = 'iperf3 --forceflush --client %s' % server_address
    # Only use IPv6
    if version6:
        cmd += ' --version6'
    # Client address
    cmd += ' --bind %s' % client_address
    # Set server port
    if server_port is not None:
        cmd += ' --port %s' % server_port
    # Time in seconds to transmit for
    if duration is not None:
        cmd += ' --time %s' % duration
    # Set target bitrate (in bits/sec)
    if bandwidth is not None:
        cmd += ' --bitrate %s' % bandwidth
    # Set TCP/SCTP maximum segment size
    if mss is not None:
        cmd += ' --set-mss %s' % mss
    # Number of parallel number of streams to run
    if num_streams is not None:
        cmd += ' --parallel %s' % num_streams
    # Define whether to run in reverse mode or not
    if reverse:
        cmd += ' --reverse'
    # Define whether to test in both directions (normal and reverse)
    if bidir:
        cmd += ' --bidir'
    # Define whether to use a 'zero copy' method of sending data,
    # such as sendfile, instead of the usual write
    if zerocopy:
        cmd += ' --zerocopy'
    # Print command
    if verbose:
        print(cmd)
    # Execute the command in a new process and redirect output to PIPE
    p = Popen(cmd, shell=True, stdout=PIPE)
    # Iterate on the output generated by iperf3
    while True:
        # Read a line
        out = p.stdout.readline()
        # Check if the process has terminated
        if out == '' and p.poll() is not None:
            break
        # Parse the output generated by iperf3
        if out != '':
            # Parse data
            res = parse_data_client(out, verbose)
            if res is not None:
                pass  # TODO send data


def parse_arguments():
    """Parse options received from command-line"""

    # Get parser
    parser = ArgumentParser(
        description='Traffic Generator'
    )
    # Run in client mode
    parser.add_argument(
        '-c', '--client', dest='host', action='store',
        default=None, help='Run in client mode, connecting to the '
        'specified server'
    )
    # Run in server mode
    parser.add_argument(
        '-s', '--server', dest='server', action='store_true',
        default=False, help='Run in server mode'
    )
    # Bind to the specific interface associated with the address
    parser.add_argument(
        '-B', '--bind', dest='bind', action='store',
        default=None,
        help='Bind to the specific interface associated with the address'
    )
    # Server port to listen on/connect to
    parser.add_argument(
        '-p', '--port', dest='port', action='store',
        default=None, help='Server port to listen on/connect to'
    )
    # Time in seconds to transmit for
    parser.add_argument(
        '-t', '--time', dest='time', action='store',
        default=None, help='Time in seconds to transmit for'
    )
    # Set target bitrate (in bits/sec)
    parser.add_argument(
        '-b', '--bitrate', dest='bitrate', action='store',
        default=None, help='Target bitrate'
    )
    # Set TCP/SCTP maximum segment size
    parser.add_argument(
        '-M', '--set-mss', dest='set_mss', action='store',
        default=None, help='TCP/SCTP maximum segment size'
    )
    # Number of parallel number of streams to run
    parser.add_argument(
        '-P', '--parallel', dest='parallel', action='store',
        default=None, help='Number of parallel number of streams to run'
    )
    # Define whether to run in reverse mode or not
    parser.add_argument(
        '-R', '--reverse', dest='reverse', action='store_true',
        default=False, help='Reverse the direction of a test, so that'
        'the server sends data to the client'
    )
    # Define whether to test in both directions (normal and reverse)
    parser.add_argument(
        '--bidir', dest='bidir', action='store_true',
        default=False, help='Test in both directions (normal and reverse),'
        'with both the client and the server sending and receiving data '
        'simultaneously'
    )
    # Define whether to use a 'zero copy' method of sending data,
    # such as sendfile, instead of the usual write
    parser.add_argument(
        '--zerocopy', dest='zerocopy', action='store_true',
        default=False, help='Use a zero copy method of sending data'
        'such as sendfile, instead of the usual write'
    )
    # Only use IPv6
    parser.add_argument(
        '-6', '--version6', dest='version6', action='store_true',
        default=False, help='Only use IPv6'
    )
    # Define whether to enable debug mode or not
    parser.add_argument(
        '-d', '--debug', action='store_true', help='Activate debug logs'
    )
    # Define whether to enable verbose mode or not
    parser.add_argument(
        '-v', '--verbose', action='store_true', help='Enable verbose mode'
    )
    # Parse input parameters
    args = parser.parse_args()
    # Return the arguments
    return args


if __name__ == "__main__":
    # Parse arguments
    args = parse_arguments()
    # Run in server mode
    server = args.server
    # Run in client mode
    host = args.host
    client = host is not None
    # Bind to the specific interface associated with the address
    bind = args.bind
    # Server port to listen on/connect to
    port = args.port
    # Time in seconds to transmit for
    time = args.time
    # Set target bitrate (in bits/sec)
    bitrate = args.bitrate
    # Set TCP/SCTP maximum segment size
    set_mss = args.set_mss
    # Number of parallel number of streams to run
    parallel = args.parallel
    # Define whether to run in reverse mode or not
    reverse = args.reverse
    # Define whether to test in both directions (normal and reverse)
    bidir = args.bidir
    # Define whether to use a 'zero copy' method of sending data,
    # such as sendfile, instead of the usual write
    zerocopy = args.zerocopy
    # Only use IPv6
    version6 = args.version6
    # Define whether to enable debug mode or not
    debug = args.debug
    # Define whether to enable verbose mode or not
    verbose = args.verbose
    # Start server/client
    if server and client:
        print('Parameter error: cannot be both server and client')
    elif not server and not client:
        print('Parameter error: must either be a client (-c) or a server (-s)')
    elif server and not client:
        start_server(
            address=bind,
            port=port,
            verbose=verbose
        )
    elif client and not server:
        start_client(
            client_address=bind,
            server_address=host,
            server_port=port,
            duration=time,
            bandwidth=bitrate,
            num_streams=parallel,
            mss=set_mss,
            bidir=bidir,
            reverse=reverse,
            zerocopy=zerocopy,
            version6=version6,
            verbose=verbose
        )
    else:
        print('Invalid params')
